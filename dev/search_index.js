var documenterSearchIndex = {"docs":
[{"location":"h3/#About-H3","page":"About H3","title":"About H3","text":"","category":"section"},{"location":"h3/","page":"About H3","title":"About H3","text":"Primary Resource: https://h3geo.org/docs/","category":"page"},{"location":"h3/#Resolutions","page":"About H3","title":"Resolutions","text":"","category":"section"},{"location":"h3/","page":"About H3","title":"About H3","text":"H3 has 16 resolutions (0 - 15).","category":"page"},{"location":"h3/","page":"About H3","title":"About H3","text":"using HexEarth, CairoMakie, GeoMakie\nimport GeoInterface as GI\n\nnew_york = (-74, 40.7)\n\nareas = [HexEarth.area(Cell(new_york, res)) for res in 0:15]\n\nbarplot(0:15, areas, axis=(; yscale=log2, ylabel=\"Log2(m ^ 2)\", xlabel = \"Resolution\", title=\"Cell Area (m^2) on Log Scale\"))","category":"page"},{"location":"h3/","page":"About H3","title":"About H3","text":"Resolutions are a hierarchy, with parents having 7 children.\nParent cells do not perfectly divide into its children cells.","category":"page"},{"location":"h3/","page":"About H3","title":"About H3","text":"o = Cell(new_york, 0)\n\nfig = Figure()\nax = Axis(fig[1,1], title=\"Cell and Children\")\npoly!(ax, o)\nfor res in 0:15\n    lines!(ax, HexEarth.children(o))\nend\nfig","category":"page"},{"location":"h3/#Orientation","page":"About H3","title":"Orientation","text":"","category":"section"},{"location":"h3/","page":"About H3","title":"About H3","text":"Resolutions alternate rotating the grid back and forth by ~19.1°.\nThese hexagonal grids are really only consistent over a face of an icosahedron (20-sided polyhedron).\nThere will be some distortion at the boundaries of the icosahedron faces, specificially at the 12 points of the icosahedron, which are pentagons.","category":"page"},{"location":"h3/","page":"About H3","title":"About H3","text":"fig = Figure()\nax = Axis(fig[1,1], title=\"Cells at Resolutions 0-3\")\nfor res in 0:3\n    poly!(ax, Cell(new_york, res))\nend\nscatter!(ax, new_york; color = :black)\n\nax2 = Axis(fig[1,2], title=\"Pentagon Distortion\")\no = Cell((0,0), 0)\npoly!(ax2, o)\nlines!(ax2, Cell((0,-5), 0))\nlines!(ax2, Cell((0, 10), 0))\nlines!(ax2, Cell((-10, -10), 0))\nlines!(ax2, Cell((-10, 10), 0))\nlines!(ax2, Cell((-20, 0), 0))\n\nfig","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Pages = [\"api.md\"]\nDepth = 3","category":"page"},{"location":"api/#HexEarth.Cell","page":"API","title":"HexEarth.Cell","text":"Cell(index::UInt64)\nCell(lonlat::Tuple{<:Real, <:Real}, res::Integer=10)\n\nA hexagonal cell in the H3 grid.\n\n\n\n\n\n","category":"type"},{"location":"api/#HexEarth.DirectedEdge","page":"API","title":"HexEarth.DirectedEdge","text":"DirectedEdge(a::Cell, b::Cell)\n\nRepresents a directional relationship between adjacent cells a and b.\n\n\n\n\n\n","category":"type"},{"location":"api/#HexEarth.GridIJ","page":"API","title":"HexEarth.GridIJ","text":"GridIJ(origin::Cell)\n\nCreate a 2D grid of cells indexed by (i, j) coordinates relative to an origin cell.  Axes are 120° apart.\n\nUnlike libh3, (0, 0) will always correspond to the origin cell.\nPentagon distortion may result in some cells having multiple (i, j) coordinates.\nSee also GridIJK.\n\n\n\n\n\n","category":"type"},{"location":"api/#HexEarth.GridIJK","page":"API","title":"HexEarth.GridIJK","text":"GridIJK(origin::Cell)\n\nCreate a 2D grid of cells indexed by (i, j, k) coordinates relative to an origin cell.\n\nUnlike libh3, (0, 0, 0) will always correspond to the origin cell.\nNote there are multiple valid (i, j, k) coordinates for a given cell.\nSee also GridIJ.\n\n\n\n\n\n","category":"type"},{"location":"api/#HexEarth.H3IndexType","page":"API","title":"HexEarth.H3IndexType","text":"One of the H3 index types: Cell, Vertex, or DirectedEdge.\n\n\n\n\n\n","category":"type"},{"location":"api/#HexEarth.Vertex","page":"API","title":"HexEarth.Vertex","text":"Vertex(index::UInt64)\n\nRepresents a vertex (point on a Cell boundary) in the H3 grid.\n\n\n\n\n\n","category":"type"},{"location":"api/#HexEarth.cells","page":"API","title":"HexEarth.cells","text":"cells(geometry, res = 10)\ncells(polygon, res = 10; containment = nothing)\ncells(raster, res = 10; dropmissing = true, dropempty = true, containment = :overlap)\n\nReturn a Vector{Cell} covering the given geometry at the specified H3 resolution (default 10).\n\n(Multi)polygons allow specifying a containment mode:\nnothing: (default) use libh3's default polygonToCells behavior (we think this is equivalent to :center)\n:center: include cells whose center point is within the polygon\n:full: include cells fully contained within the polygon\n:overlap: include cells that overlap the polygon at all\n:overlap_bbox: include cells that overlap the polygon's bounding box\nRasters (requires Rasters.jl to be loaded)\n\n\n\n\n\n","category":"function"},{"location":"api/#HexEarth.grid_disk-Tuple{Cell, Integer}","page":"API","title":"HexEarth.grid_disk","text":"grid_disk(o::Cell, k::Integer)\n\nReturn all cells within k steps of origin cell o, including o itself.\n\n\n\n\n\n","category":"method"},{"location":"api/#HexEarth.grid_path_cells-Tuple{Cell, Cell}","page":"API","title":"HexEarth.grid_path_cells","text":"grid_path_cells(a::Cell, b::Cell)\n\nReturn a minimal-length contiguous path of cells from a to b.\n\n\n\n\n\n","category":"method"},{"location":"api/#HexEarth.grid_ring_unsafe-Tuple{Cell, Integer}","page":"API","title":"HexEarth.grid_ring_unsafe","text":"grid_ring_unsafe(o::Cell, k::Integer)\n\nReturn all cells exactly k steps from origin cell o. The order of the returned cells is not guaranteed.\n\nPer h3 documentation, \"This function may fail if pentagonal distortion is encountered.\"  We don't know what that means.\n\n\n\n\n\n","category":"method"},{"location":"api/#HexEarth.resolution-Tuple{UInt64}","page":"API","title":"HexEarth.resolution","text":"resolution(::UInt64)\nresolution(::Cell)\nresolution(::Vertex)\nresolution(::DirectedEdge)\n\nReturn the resolution 0-15 (coarse to fine) of the given H3 index.\n\n\n\n\n\n","category":"method"},{"location":"api/#HexEarth.split_index-Tuple{UInt64}","page":"API","title":"HexEarth.split_index","text":"split_index(x::UInt64) -> NamedTuple\n\nSplit a 64-bit H3 index into its fields per the spec:\n\nmode (4 bits)\nresolution (4 bits, 0–15)\nbasecell (7 bits, 0–121)\ndigits (15 three-bit digits; unused digits are 7)\n\nReferences:\n\nH3 bit layout & cell index fields. See docs.\n\n\n\n\n\n","category":"method"},{"location":"api/#HexEarth.Geo.R","page":"API","title":"HexEarth.Geo.R","text":"Approximate radius of the earth in meters (WGS84).\n\n\n\n\n\n","category":"constant"},{"location":"api/#HexEarth.Geo.destination-Tuple{Any, Any, Any}","page":"API","title":"HexEarth.Geo.destination","text":"destination(x, azimuth°, dist_m)\n\nFind destination point given starting point x (longitude/latitude in degrees), azimuth (clockwise from North), and dist_m (meters).\n\n\n\n\n\n","category":"method"},{"location":"api/#HexEarth.Geo.haversine-Tuple{Any, Any}","page":"API","title":"HexEarth.Geo.haversine","text":"haversine(a, b)\n\nCalculate the great-circle distance (meters) between two (lon, lat) points using the Haversine formula. a and b are any iterables of length 2 representing (lon, lat).\n\n\n\n\n\n","category":"method"},{"location":"rasters/#Rasters-to-Cells","page":"Rasters to Cells","title":"Rasters to Cells","text":"","category":"section"},{"location":"rasters/","page":"Rasters to Cells","title":"Rasters to Cells","text":"For rasters, cells returns Dict{Cell, Vector{T}} where T is the eltype of the raster.\nBy default, missing values from the raster will not be included.  Use dropmissing=false to include them.","category":"page"},{"location":"rasters/","page":"Rasters to Cells","title":"Rasters to Cells","text":"using HexEarth, GeoMakie, CairoMakie, Rasters, RasterDataSources, ArchGDAL\n\nr = Raster(getraster(WorldClim{Elevation}).elev)\n\ndict = cells(r, 2)\n\n# remove hexagons overlapping 180° longitude to avoid plotting\n# horizontal \"stripes\" across the map\ndict2 = filter(kv -> !HexEarth.crosses_lon180(kv[1]), dict)\n\npoly(collect(keys(dict2)), color=maximum.(values(dict2)), axis=(;type = GeoAxis))","category":"page"},{"location":"geometry_to_cell/#Geometry-to-Cells","page":"Geometry to Cells","title":"Geometry to Cells","text":"","category":"section"},{"location":"geometry_to_cell/","page":"Geometry to Cells","title":"Geometry to Cells","text":"The main function to create a collection of cells that approximate a geometry is cells:","category":"page"},{"location":"geometry_to_cell/","page":"Geometry to Cells","title":"Geometry to Cells","text":"cells(geometry, res::Int)::Vector{Cell}","category":"page"},{"location":"geometry_to_cell/#Point","page":"Geometry to Cells","title":"Point","text":"","category":"section"},{"location":"geometry_to_cell/","page":"Geometry to Cells","title":"Geometry to Cells","text":"pt = (0, 0)\n\ncell = Cell(pt)\n\np = lines(cell)\nscatter!(pt, color=0)\np","category":"page"},{"location":"geometry_to_cell/#LineString","page":"Geometry to Cells","title":"LineString","text":"","category":"section"},{"location":"geometry_to_cell/","page":"Geometry to Cells","title":"Geometry to Cells","text":"By default, the cells function will create a shortest path between the cells that contain the two points of each line.  You can set shortest_path=false to include all hexagons that overlap the lines.","category":"page"},{"location":"geometry_to_cell/","page":"Geometry to Cells","title":"Geometry to Cells","text":"import GeoInterface as GI\n\nls = GI.LineString([(0,0), (1,1), (-1,2)])\n\nx = cells(ls, 6)\nx2 = cells(ls, 6; shortest_path=false)\n\nfig = Figure()\nax = Axis(fig[1,1], title=\"shortest_path = true\")\nax2 = Axis(fig[1,2], title=\"shortest_path = false\")\nlines!(ax, x)\nlines!(ax, ls.geom)\nlines!(ax2, x2)\nlines!(ax2, ls.geom)\nfig","category":"page"},{"location":"geometry_to_cell/#(Multi)Polygon","page":"Geometry to Cells","title":"(Multi)Polygon","text":"","category":"section"},{"location":"geometry_to_cell/","page":"Geometry to Cells","title":"Geometry to Cells","text":"There are several algorithms available for filling in cells based on a polygon, based on keyword argument containment.\ncontainment = nothing (the default) will use the H3.Lib.polygonToCells function.\nOther containment modes (:center, :full, :overlap, or :overlap_bbox) will use H3.Lib.polygonToCellsExperimental.\nAs far as we can tell containment = :center uses the same algorithm as containment = nothing.","category":"page"},{"location":"geometry_to_cell/","page":"Geometry to Cells","title":"Geometry to Cells","text":"using GeoJSON\n\n# Get GeoJSON polygon of North Carolina\nurl = \"https://nominatim.openstreetmap.org/search?state=north_carolina&format=geojson&polygon_geojson=1\"\nfile = download(url)\nobj = GeoJSON.read(file)\n\n# Create figure\nfunction make_axis(i, j, res, containment)\n    ax = Axis(fig[i, j], title=\"containment = $containment\")\n    x = cells(obj.geometry[1], res; containment)\n    lines!(ax, x)\n    lines!(ax, obj.geometry)\nend\nfig = Figure()\nmake_axis(1, 1, 4, nothing)\nmake_axis(1, 2, 4, :center)\nmake_axis(1, 3, 4, :full)\nmake_axis(2, 1, 4, :overlap)\nmake_axis(2, 2, 4, :overlap_bbox)\nfig","category":"page"},{"location":"geometry_to_cell/#Extents","page":"Geometry to Cells","title":"Extents","text":"","category":"section"},{"location":"geometry_to_cell/","page":"Geometry to Cells","title":"Geometry to Cells","text":"Uses the same containment options as for (Multi)polygons.","category":"page"},{"location":"geometry_to_cell/","page":"Geometry to Cells","title":"Geometry to Cells","text":"ex = GI.extent(obj)\n\n# for plotting\nx1, x2 = ex.X\ny1, y2 = ex.Y\nlinestring = GI.LineString([(x1,y1), (x1,y2), (x2,y2), (x2, y1), (x1,y1)])\n\n# Create figure\nfunction make_axis(i, j, res, containment)\n    ax = Axis(fig[i, j], title=\"containment = $containment\")\n    x = cells(ex, res; containment)\n    # lines!(ax, obj.geometry)\n    lines!(ax, linestring)\n    lines!(ax, x)\nend\nfig = Figure()\nmake_axis(1, 1, 4, :center)\nmake_axis(1, 2, 4, :full)\nmake_axis(2, 1, 4, :overlap)\nmake_axis(2, 2, 4, :overlap_bbox)\nfig","category":"page"},{"location":"indexing/#Indexing","page":"Indexing","title":"Indexing","text":"","category":"section"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"Cells are uniquely identified by a UInt64 index.  The only global indexing system is through these values.\nYou can create cells from its index or from coordinates that are contained in the cell: Cell(index) or Cell((lon, lat), res=10).\nHowever, H3 supports several other indexing systems that are valid within a single face of the icosahedron.\nHexEarth uses several different getindex methods to expose these indexing systems.","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"important: Index Ordering\nIndex ordering is not consistent.  I.e. there are no directional guarantees as to where cell[1] is relative to cell.","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"using HexEarth\n\nnew_york = (-74, 40.7)\n\ncell = Cell(new_york)\n\ncell[1]  # spiral indexing (1-6) for immediate neighbors\n\ncell[0, 1]  # https://h3geo.org/docs/core-library/coordsystems#local-ij-coordinates\n\ncell[0, 1, 0]  # https://h3geo.org/docs/core-library/coordsystems#ijk-coordinates","category":"page"},{"location":"indexing/#Spiral-Indexing","page":"Indexing","title":"Spiral Indexing","text":"","category":"section"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"import GeoInterface as GI\nusing CairoMakie\n\nfig = Figure()\nax = Axis(fig[1,1])\npoly!(ax, cell)\nfor i in 1:6\n    lines!(ax, cell[i])\n    text!(ax, GI.centroid(cell[i]), text=string(i))\nend\nfig","category":"page"},{"location":"indexing/#IJ-Indexing","page":"Indexing","title":"IJ Indexing","text":"","category":"section"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"note: Note\nFor IJ/IJK indexing, HexEarth uses the conventions that (0,0) and (0,0,0) refer to the origin cell.  For whatever reason, this is not the case in the original h3 library.","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"Reference: https://h3geo.org/docs/core-library/coordsystems/#local-ij-coordinates","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"fig = Figure()\nax = Axis(fig[1,1])\npoly!(ax, cell)\nfor i in [(0,1), (0,-1), (-1,-1), (1,1), (1,0), (-1,0)]\n    lines!(ax, cell[i...])\n    text!(ax, GI.centroid(cell[i...]), text=string(i))\nend\nfig","category":"page"},{"location":"indexing/#IJK-Indexing","page":"Indexing","title":"IJK Indexing","text":"","category":"section"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"Reference: https://h3geo.org/docs/core-library/coordsystems#ijk-coordinates\nIJK addresses are not unique unless \"normalized\"\nNote: normalized IJK coordinates have at most two non-zero coordinates.","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"(Image: )","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"fig = Figure()\nax = Axis(fig[1,1])\npoly!(ax, cell)\nfor i in HexEarth.neighbor_indices\n    @info i\n    lines!(ax, cell[i...])\n    text!(ax, GI.centroid(cell[i...]), text=string(i))\nend\nfig","category":"page"},{"location":"#HexEarth.jl","page":"Home","title":"HexEarth.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HexEarth provides tools built on top of H3.jl for working with Uber's H3 grid system.","category":"page"},{"location":"","page":"Home","title":"Home","text":"tip: What does HexEarth do?\nThe primary purpose of this package is to join disparate vector and raster datasets to a unified hexagonal grid.","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"All coordinates are assumed to be in EPSG:4326 (WGS84 lon/lat in degrees)\nHexagon cell resolutions are 0-15 (coarse-to-fine).  Resolution 15 corresponds to cells with areas smaller than 1 meter.\nAll distances are assumed to be (and returned in) meters.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using HexEarth\nimport GeoInterface as GI\n\nnew_york = (-75.0, 43.0)\n\ncell = Cell(new_york, 10)\n\nHexEarth.area(cell)  # meters ^ 2\n\nGI.centroid(cell)","category":"page"}]
}
