var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Pages = [\"api.md\"]\nDepth = 3","category":"page"},{"location":"api/#HexEarth.DirectedEdge","page":"API","title":"HexEarth.DirectedEdge","text":"DirectedEdge(a::Cell, b::Cell)\n\nRepresents a directional relationship between adjacent cells a and b.\n\n\n\n\n\n","category":"type"},{"location":"api/#HexEarth.GridIJ","page":"API","title":"HexEarth.GridIJ","text":"GridIJ(origin::Cell)\n\nCreate a 2D grid of cells indexed by (i, j) coordinates relative to an origin cell.  Axes are 120° apart.\n\nUnlike libh3, (0, 0) will always correspond to the origin cell.\nPentagon distortion may result in some cells having multiple (i, j) coordinates.\nSee also GridIJK.\n\n\n\n\n\n","category":"type"},{"location":"api/#HexEarth.GridIJK","page":"API","title":"HexEarth.GridIJK","text":"GridIJK(origin::Cell)\n\nCreate a 2D grid of cells indexed by (i, j, k) coordinates relative to an origin cell.\n\nUnlike libh3, (0, 0, 0) will always correspond to the origin cell.\nNote there are multiple valid (i, j, k) coordinates for a given cell.\nSee also GridIJ.\n\n\n\n\n\n","category":"type"},{"location":"api/#HexEarth.H3IndexType","page":"API","title":"HexEarth.H3IndexType","text":"One of the H3 index types: Cell, Vertex, or DirectedEdge.\n\n\n\n\n\n","category":"type"},{"location":"api/#HexEarth.Vertex","page":"API","title":"HexEarth.Vertex","text":"Vertex(index::UInt64)\n\nRepresents a vertex (point on a Cell boundary) in the H3 grid.\n\n\n\n\n\n","category":"type"},{"location":"api/#HexEarth.cells","page":"API","title":"HexEarth.cells","text":"cells(geometry, res = 10)\n\nReturn a Vector{Cell} covering the given geometry at the specified H3 resolution (default 10).\n\n\n\n\n\n","category":"function"},{"location":"api/#HexEarth.grid_disk-Tuple{Cell, Integer}","page":"API","title":"HexEarth.grid_disk","text":"grid_disk(o::Cell, k::Integer)\n\nReturn all cells within k steps of origin cell o, including o itself.\n\n\n\n\n\n","category":"method"},{"location":"api/#HexEarth.grid_path_cells-Tuple{Cell, Cell}","page":"API","title":"HexEarth.grid_path_cells","text":"grid_path_cells(a::Cell, b::Cell)\n\nReturn a minimal-length contiguous path of cells from a to b.\n\n\n\n\n\n","category":"method"},{"location":"api/#HexEarth.grid_ring_unsafe-Tuple{Cell, Integer}","page":"API","title":"HexEarth.grid_ring_unsafe","text":"grid_ring_unsafe(o::Cell, k::Integer)\n\nReturn all cells exactly k steps from origin cell o. The order of the returned cells is not guaranteed.\n\nPer h3 documentation, \"This function may fail if pentagonal distortion is encountered.\"  We don't know what that means.\n\n\n\n\n\n","category":"method"},{"location":"api/#HexEarth.resolution-Tuple{UInt64}","page":"API","title":"HexEarth.resolution","text":"resolution(::UInt64)\nresolution(::Cell)\nresolution(::Vertex)\nresolution(::DirectedEdge)\n\nReturn the resolution 0-15 (coarse to fine) of the given H3 index.\n\n\n\n\n\n","category":"method"},{"location":"api/#HexEarth.split_index-Tuple{UInt64}","page":"API","title":"HexEarth.split_index","text":"split_index(x::UInt64) -> NamedTuple\n\nSplit a 64-bit H3 index into its fields per the spec:\n\nmode (4 bits)\nresolution (4 bits, 0–15)\nbasecell (7 bits, 0–121)\ndigits (15 three-bit digits; unused digits are 7)\n\nReferences:\n\nH3 bit layout & cell index fields. See docs.\n\n\n\n\n\n","category":"method"},{"location":"api/#HexEarth.Geo.R","page":"API","title":"HexEarth.Geo.R","text":"Approximate radius of the earth in meters (WGS84).\n\n\n\n\n\n","category":"constant"},{"location":"api/#HexEarth.Geo.destination-Tuple{Any, Any, Any}","page":"API","title":"HexEarth.Geo.destination","text":"destination(x, azimuth°, dist_m)\n\nFind destination point given starting point x (longitude/latitude in degrees), azimuth (clockwise from North), and dist_m (meters).\n\n\n\n\n\n","category":"method"},{"location":"api/#HexEarth.Geo.haversine-Tuple{Any, Any}","page":"API","title":"HexEarth.Geo.haversine","text":"haversine(a, b)\n\nCalculate the great-circle distance (meters) between two (lon, lat) points using the Haversine formula. a and b are any iterables of length 2 representing (lon, lat).\n\n\n\n\n\n","category":"method"},{"location":"geometry_to_cell/#Geometry-to-Cell","page":"Geometry to Cells","title":"Geometry to Cell","text":"","category":"section"},{"location":"geometry_to_cell/","page":"Geometry to Cells","title":"Geometry to Cells","text":"The main function to create a collection of cells that approximate a geometry is cells:","category":"page"},{"location":"geometry_to_cell/","page":"Geometry to Cells","title":"Geometry to Cells","text":"cells(geometry, res::Int)::Vector{Cell}","category":"page"},{"location":"geometry_to_cell/#Point","page":"Geometry to Cells","title":"Point","text":"","category":"section"},{"location":"geometry_to_cell/","page":"Geometry to Cells","title":"Geometry to Cells","text":"pt = (0, 0)\n\ncell = Cell(pt)\n\np = lines(cell)\nscatter!(pt, color=0)\np","category":"page"},{"location":"geometry_to_cell/#LineString","page":"Geometry to Cells","title":"LineString","text":"","category":"section"},{"location":"geometry_to_cell/","page":"Geometry to Cells","title":"Geometry to Cells","text":"Notice that the lines are not entirely covered by hexagons.  The cells function will create a","category":"page"},{"location":"geometry_to_cell/","page":"Geometry to Cells","title":"Geometry to Cells","text":"shortest path between the two points and does not check intermediate points on the line.","category":"page"},{"location":"geometry_to_cell/","page":"Geometry to Cells","title":"Geometry to Cells","text":"import GeoInterface as GI\n\nls = GI.LineString([(0,0), (1,1), (-1,2)])\n\nx = cells(ls, 6)\n\np = lines(x)\nlines!(ls.geom)\np","category":"page"},{"location":"geometry_to_cell/#(Multi)Polygon","page":"Geometry to Cells","title":"(Multi)Polygon","text":"","category":"section"},{"location":"geometry_to_cell/","page":"Geometry to Cells","title":"Geometry to Cells","text":"There are several algorithms available for filling in cells based on a polygon, based on keyword argument containment.\ncontainment = nothing (the default) will use the H3.Lib.polygonToCells function.\nOther containment modes (:center, :full, :overlap, or :overlap_bbox) will use H3.Lib.polygonToCellsExperimental.\nAs far as we can tell containment = :center uses the same algorithm as containment = nothing.","category":"page"},{"location":"geometry_to_cell/","page":"Geometry to Cells","title":"Geometry to Cells","text":"using GeoJSON\n\n# Get GeoJSON polygon of North Carolina\nurl = \"https://nominatim.openstreetmap.org/search?state=north_carolina&format=geojson&polygon_geojson=1\"\nfile = download(url)\nobj = GeoJSON.read(file)\n\n# Create figure\nfunction make_axis(i, j, res, containment)\n    ax = Axis(fig[i, j], title=\"containment = $containment\")\n    x = cells(obj.geometry[1], res; containment)\n    lines!(ax, obj.geometry)\n    lines!(ax, x)\nend\nfig = Figure()\nmake_axis(1, 1, 4, nothing)\nmake_axis(1, 2, 4, :center)\nmake_axis(1, 3, 4, :full)\nmake_axis(2, 1, 4, :overlap)\nmake_axis(2, 2, 4, :overlap_bbox)\nfig","category":"page"},{"location":"geometry_to_cell/#Extents","page":"Geometry to Cells","title":"Extents","text":"","category":"section"},{"location":"geometry_to_cell/","page":"Geometry to Cells","title":"Geometry to Cells","text":"Uses the same containment options as for (Multi)polygons.","category":"page"},{"location":"geometry_to_cell/","page":"Geometry to Cells","title":"Geometry to Cells","text":"ex = GI.extent(obj)\n\n# for plotting\nx1, x2 = ex.X\ny1, y2 = ex.Y\nlinestring = GI.LineString([(x1,y1), (x1,y2), (x2,y2), (x2, y1), (x1,y1)])\n\n# Create figure\nfunction make_axis(i, j, res, containment)\n    ax = Axis(fig[i, j], title=\"containment = $containment\")\n    x = cells(ex, res; containment)\n    lines!(ax, obj.geometry)\n    lines!(ax, linestring)\n    lines!(ax, x)\nend\nfig = Figure()\nmake_axis(1, 1, 4, :center)\nmake_axis(1, 2, 4, :full)\nmake_axis(2, 1, 4, :overlap)\nmake_axis(2, 2, 4, :overlap_bbox)\nfig","category":"page"},{"location":"geometry_to_cell/#Rasters","page":"Geometry to Cells","title":"Rasters","text":"","category":"section"},{"location":"geometry_to_cell/","page":"Geometry to Cells","title":"Geometry to Cells","text":"For rasters, cells returns Dict{Cell, Vector{T}} where T is the eltype of the raster.","category":"page"},{"location":"geometry_to_cell/","page":"Geometry to Cells","title":"Geometry to Cells","text":"using Rasters, RasterDataSources, ArchGDAL\n\n(; elev) = getraster(WorldClim{Elevation})\n\nr = Raster(elev)\n\nnc_ext = GI.extent(obj.geometry[1])\n\nr_nc = mask(r, with=obj.geometry[1])\n\nnc_elev = view(r_nc, nc_ext)\n\nx = cells(nc_elev, 4)\n\npoly(collect(keys(x)); color=maximum.(values(x)))","category":"page"},{"location":"geometry_to_cell/#Resolution-Issues","page":"Geometry to Cells","title":"Resolution Issues","text":"","category":"section"},{"location":"geometry_to_cell/","page":"Geometry to Cells","title":"Geometry to Cells","text":"At higher Cell resolutions, you may end up with holes:","category":"page"},{"location":"geometry_to_cell/","page":"Geometry to Cells","title":"Geometry to Cells","text":"x = cells(nc_elev, 5)\n\npoly(collect(keys(x)); color=maximum.(values(x)))","category":"page"},{"location":"geometry_to_cell/","page":"Geometry to Cells","title":"Geometry to Cells","text":"cells accepts a \"mask\" as a first argument which will:\nCreate the cells based on the geometry.\nPopulate the cells' data based on the raster.\nCells that would otherwise have been empty will now use the nearest raster pixel.","category":"page"},{"location":"geometry_to_cell/","page":"Geometry to Cells","title":"Geometry to Cells","text":"x = cells(obj.geometry[1], nc_elev, 5)\n\npoly(collect(keys(x)); color=maximum.(values(x)))","category":"page"},{"location":"#HexEarth.jl","page":"Home","title":"HexEarth.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HexEarth provides tools built on top of H3.jl for working with Uber's H3 grid system.","category":"page"},{"location":"","page":"Home","title":"Home","text":"tip: What does HexEarth do?\nThe primary purpose of this package is to join disparate vector and raster datasets to a unified hexagonal grid.","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"All coordinates are assumed to be in EPSG:4326 (WGS84 lon/lat in degrees)\nHexagon cell resolutions are 0-15 (coarse-to-fine).  Resolution 15 corresponds to cells with areas smaller than 1 meter.\nAll distances are assumed to be (and returned in) meters.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using HexEarth\nimport GeoInterface as GI\n\nnew_york = (-75.0, 43.0)\n\ncell = Cell(new_york, 10)\n\nHexEarth.area(cell)  # meters ^ 2\n\nGI.centroid(cell)","category":"page"}]
}
